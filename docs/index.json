[{"uri":"\\posts\\2.7-cc%2B%2B-pointer","tags":["PAT"],"content":" 指针 什么 是 指针 指针 就是 变量 的 地址  ( 不 严谨 ) 指针 是 一个 unsigned 类型 的 整数 指针 变量 指针 变量 是 用来 存放 指针 的 ( 也 可以 理解 程 地址 ) 在 数据类型 后面 加  `  表示 这 是 一个 指针 变量 . 或者 在 变量 前 加  ` , 都 是 可以 的 给 指针 变量 赋值      把 变量 的 地址 取出 来 , 然后 赋 给 对应 类型 的 指针 变量 . &  是 取 址 运算符      注意  :  地址  &a 是 赋值 给 p 而 不是 p 的 . 因为 允许    放在 变量 前面 ,p 才 是 变量 , 容易 混淆 .   只要 知道 星号 是 类型 的 一部分 就 可以 .    `c++    int a;    int *p = &a;    ` 现在 指针 变量  p  存放 了 a 的 地址 . 如何 通过 p  获取 变量 a 呢 ?   把  *  视作   开启 房间 的 钥匙 , 放在  p  前面 , 就 可以 获取 变量 a 的 值     `c++    #include    int main(){        int a;        int *p  = &a;        a = 233;        printf(\"%d\\n\",*p);        return 0;    }     输出 结果 :    233    ` 对  *p  直接 赋值 , 地址 没有 改变 , 改变 了 房间内 的 元素 ,a  也 改变     `c++    #include    int main(){        int a;        int *p  = &a;        *p = 233;        printf(\"%d,%d\\n\",*p,a);        return 0;    }     输出 结果 :    233,233    `p + 1  是 指 p 所指 的 int 型 变量 的 下 一个 int 型 变量 地址 , 下 一个 是 跨越 了 一 整个 int(4Byte).   指针 变量 支持 自 增 自 减  p++,p-- 对 指针 变量 来说 , 其 存储 的 地址 的 类型 称为 基 类型 . int *p; int 是 基 类型 , 指针 变量 p 不能 存放 double,char 类型 数据 的 地址 . 指针 与 数组 &a[0]   首 地址 数组 名称 也 作为 数组 的 首 地址 使用  *p = a  则 指针 变量  p 的 地址 是  &a[0] 指针 变量 可以 进行 加减法 , 可以 退出 数组 a+i  等同于  &a[i] 需要 注意 : a+i 只是 地址 , 访问 需要 加上 `, 变成 (a+i) 才 可以 和 a[i]` 等价 .  所以 有 一种 新颖 的 输入输出 数组 写法 `c++    #include    int main(){        int a[10];        for(int i = 0;i    int main(){        int a[10] = {1,2,3,4,5,6,7,8,9,10};        for(int *p = a;pvoid swap(int a,int b){\tint temp = *a;\ta = b;\t*b = temp;}int main(){    int a = 1, b = 2;    int p1 = &a, p2 = &b;    swap(p1,p2);    printf(\"a = %d , b = %d\\n\", p1, p2);    printf(\"a = %d , b = %d\\n\", a, b);    return 0;}` 引用 引用 的 含义 引用 是 c++ 中 一个 强有力 的 语法 . 不 使用 指针 , 达到 修改 传入 参数 的 目的 , 使用 引用 , 不会 产生 副本 , 而是 给 原 变量 起 了 个别 名 , 相当于 旧 名字 和 新 名字 都 是 同一个 人 , 且 对 引用 变量 的 操作 就是 对 原 变量 的 操作 引用 的 使用 方法 , 只要 在 函数 的 参数 类型 后面 加上 & 就 可以 , 加 在 int 后 或 变量 前 都 可以 . 示例 :`c++#includevoid change(int &x){\tx = 1;}int main(){\tint x = 10;\tchange(x);\tprintf(\"%d\\n\",x);\treturn 0;} 输出 结果 :1`>  当然 函数 的 参数 名 和 实际 传入 参数 名 可以 不同 >  要 把 引用 的 & 和 取 址 运算符 & 区别 开来 指针 的 引用 由于 引用 是 产生 变量 的 别名 , 因此 常量 不可 使用 引用 , 不 可以 写 swap(&a,&b) 必须 要 用 指针 变量 p1,p2 存放 &a,&b, 然后 把 指针 变量 作为 参数 传入 `c++#includevoid swap(int* &p1,int* &p2){\tint* temp = p1;\tp1 = p2;\tp2 = temp;}int main(){\tint a = 1, b = 2;\tint p1 = &a, p2 = &b;\tswap(p1,p2);\tprintf(\"a = %d,b = %d\\n\",p1, p2);\treturn 0;}`","title":"C/C++  指针 ","oriTitle":"C/C++ 指针"},{"uri":"\\posts\\2017review","tags":["总结"],"content":"2017 年 总结 2017 年 是 我 改变 的 一个 重要 的 一年 . 暑假 的 时候 决定 考研 , 开学 后 , 看 了 会 书 , 但是 被 Android 比赛 耽搁 了 . 希望 在 2018 年 继续 专心 复习 .   离 2018 年 考研 还有 有 11 个 月 多 了 , 虽然 时间 还有 很多 , 但是 不知不觉 就 会 过去 了 .   而且 院校 我 还 没有 真正 的 去 了解 过 , 不 知道 考 哪 所 学校 , 寒假 要 多 了解 一下 .  下半年 在 学 Java 和   自学 了 Android.  学 了 点 Android 就 有点 沾沾自喜 , 这 是 不 应该 的 . Java 学 了 , 但是 代码 , 做 题目 的 时候 还是 很多 不会 , 面向对象 和 API 还是 模模糊糊 . 希望 明年 可以 多 复习 复习 , 多 看书 , 多 实践 .2018 的 考研 计划 :  每星期 都 制定 大 计划 , 写 在 纸条 上 , 完成 计划 就 划掉 一项 .  每天 也 要 制定 小 计划 , 时刻 监督 自己   英语单词 要 继续 背 , 放假 前 看 完   王 江 涛 的 两遍 . 寒假 里 被 新东方 绿色 的 乱序 .  英语 阅读 要 多 做 多 看   数学 :  复习 全书 和 看 视频   专业课 : 寒假 先 搞定 数据结构 , 参加 三月份 的 PAT 考试 .  寒假 回来 后 看 其他 三门 .  政治 9 月份 开始 看 时间 安排 上课 课余时间 看 英语 不 上课 , 早上 看 数学 , 下午 看 专业课 , 晚上 看 英语 主要 每天 制定 小 计划 , 一周 一个 大 计划 , 一个月 一个 大大 计划 每天 时间 都 要 规划 好 寒假 计划 数据结构   参加 三月份 PAT, 考 出 好 成绩 英语单词 不能 忘 , 数学 可以 看 会 线 代 .Java 复习 在 寒假 看 会 Python","title":"2017 年 总结 ","oriTitle":"2017年总结"},{"uri":"\\posts\\3.2.datasturcturelist","tags":["Data Sturcture","List"],"content":" 线性表 线性表 的 定义 类型 名称 :  线性表 (List) 数据 对象 集 :  有序 序列 ,(a1,a2,a3, ... ,an), a1 是 表头 ,an 是 表 尾  , 有 前驱 结点 ( 直接 前驱 ) 和 后继 结点 ( 直接 后继 ), 反映 了 元素 之间 一对一 的 邻接 逻辑关系 操作 集 :  对于 一个 具体 的 线性表  L ∈ List, 一个 表示 位 序 的 整数  i , 一个 元素  X ∈ ElementType 基本操作 有 :    List MakeEmpty(); //  初始化 新 的 空 线性表     ElementType FindKth(List L, int i); //  根据 制定 的 位 序 , 返回 L 中 相应 的 元素 ai    Position Find(List L, ElementType X); //  已知 X, 返回 线性表 中 与 X 相同 的 第一个 元素 的 位置 , 不 存在 则 返回 错误信息     bool Insert(:ist L, ElementType X, int i); //  插入 X 到 L 的 指定 位 序 , 成功 返回 true, 否则 返回 false    bool Delete(List L, int i);  //  从 L 中 删除 指定 位 序 , 数   组 下标 为 i-1, 返回 true 和 false    int Length(List L);  //  返回 线性表 L 的 长度 线性表 的 顺序存储 实现 类型定义 由于 LNode 是 一个 包含 数组 的 结构 , 使用 结构 指针 传递 效率 更 高 , 所以 我们 把 List 定义 为 结构 指针 , 利用 List 定义 线性表 L. List L; 通过 L 我们 可以 访问 相应 的 线性表 的 内容 . 下标 为 i 的 元素  L->Data[i], 线性表 的 长度  L->Last+1`c++typedef int Position;//  这里 的 位置 就是 数组 的 下标 ， 从 0 开始 .   注意 位 序 和 下 标的 不同 typedef struct LNode *PtrToLNode;struct LNode{    ElementType Data[MAXSIZE];    Posistion Last;};typedef PtrToLNode List;` 初始化  Create 顺序 表 的 初始化 即 构造 一个 空 表 . 首先 动态分配 表 结构 所 需要 的 存储空间 . 然后 将  Last  指针 置 为  -1 , 表示 表 中 没有 数据 元素 .`c++//  初始化 List MakeEmpty(){    List L;    L = (List)malloc(sizeof(struct LNode));    L->Last = -1;    return L;}` 查找 查找 给定 值 X 相等 的 数据 元素 .  从 第一个 数据 元素 a1 起 依次 与 X 比较 , 直到 找到 与 X 相等 的 数据 元素 , 返回 下标 .# 没有 找到 返回 ERROR 时间 复杂度 为 O(n).  比较 的 次数 与 位置 有关 `c++//  查找 #define ERROR = -1; //  将 错误信息 ERROR 的 值 定义 为 任一 负数 Position Find(List L, ElementType X){    Position i = 0;    while(i Last && L->Data[i] != X){        i++;    }    if(i > L->Last){        return ERROR;   //  如果 没有 找到 , 返回 错误信息     }else{        return i;       //  找到 后 返回 的 是 存储 的 位置     }}` 插入 在 表 的 第 i 个 位 序 上 插入 一个 X 新元素 , 表 的 长度 变为  n+1 .  位 序 为 1  时 , 最 前端 ,n+1  时 , 插入序列 最后 .     将 ai~an  顺序 向 后 移动 ( 顺序 是从 an 到 ai), 为 新元素 让出 位置      将 X 置入 空 出 的 第 i 个 位 序      修改 Last 指针 ( 相当于 修改 表 长 ), 使 之 仍 指向 最后 一个 元素 时间 复杂度  O(n).> 1.  检查表 是否 已 满 ? 2.  检查 位 序 合法性  3.  注意 移动 次序 和 方向 `c++//  在 L 的 制定 位 序 钱 插入 一个 新元素  X, 位 序 i 元素 的 数组 位置 下标 是 i-1bool Insert(List L, ElementType x, int i){    Position j;    if(L->Last == MAXSIZE - 1){        //  表 空间 已 满 , 不能 插入         printf(\" 表 满 \");        return false;    }    if(i  L->Last + 2){        //  检查 插入 位 序 的 合法性 , 是否 在 1~n+1.n 为 当前 元素 个数 , 即 Last+1        printf(\" 位 序 不 合法 \");        return false;    }    for( j = L->Last; j >= i-1; j--){   // Last 指向 序列 最后 元素 a        L->Data[j+1] = L->Data[j];      //  将 位 序 i 以后 的 元素 顺序 向 后 移动     }    L->Data[i-1] = X;                   //  新元素 插入 地 i 位 序 , 其 数组 下标 为 i-1    L->Last++;                          // Last 仍 指向 最后 元素     return true;}` 删除  Delete 删除 表 中 位 序 为 i 的 元素 . 删除 后 表 长 n-1     将 ai+1~an 顺序 向前 移动 ,ai  元素 被 ai+1 覆盖      修改 Last 指针 ( 相当于 修改 表 长 ) 使 之 仍 指向 最后 一个 元素 `c++//  从 L 中 删除 位 序 为 i 的 元素 , 数组 下标 为 i-1bool Delete(List L, int i){    Position j;    if( i  L->Last + 1){  //  检查 空 表 及 删除 位 序 的 合法性         printf(\" 位 序 %d 不 存在 元素 \", i);        return false;    }    for(j = i; j Last; j++){        L->Data[j-1] = L->Data[j];  //  将 位 序 i+1 及 后面 的 元素 向前 移动     }    L->Last--;      // Last  仍 指向 最后 元素     return true;}` 线性表 的 链式 存储 实现 类型定义 用 List 定义 具体 的 表头 结点 指针 , 该 指针 就 代表 一个 链式 表  List L`c++typedef struct LNode *PtrToLNode;typedef int ElementType;struct LNode{    ElementType Data;    PtrToLNode Next;};typedef PtrToLNode Position;    //  这里 的 位置 是 节点 的 地址 typedef PtrToLNode List;` 求 表 长  Length 在 顺序存储 中 直接 返回 Last+1  即可 但是 在 链式 存储 中 , 需要 将 链表 从头到尾 遍历 一遍 , 设置 一个 移动 指针  p  和 一个 计数器  cnt 初始化 后  p  从 表 的 第一个 结点 开始 逐步 往 后移 , 同时 计数器  cnt+1 . 当 后面 不 在 有 结点 时 , cnt  的 值 就是 结点 数 , 就是 表 长 .`c++//  求 线性表 L 的 长度 int Length(List L){    Position p;    int cnt = 0;    //  初始化 计数器     p = L;          // p 指向 表 的 第一个 结点     while(p){        p = p->Next;        cnt++;  //  当前 p 指向 的 是 第 cnt 个 结点     }    return cnt;}` 查找 按 序号 查找 从 链表 的 第一个 元素 结点 起 , 判断 当前 节点 是否是 第 K 个 , 若 是 , 返回 结点 的 值 , 不是 , 这 继续 后 一个 , 直到 表 结束 .  没有 第 K 个 结点 则 返回 错误信息 .`c++// 1.  查找 // 1.1  按 序号 查找 #define ERROR1 = -1;    //  一般 定义 为 表 中 无法 取得 的 值 ElementType FindKth(List L, int k){    Position p;    int cnt = 1; //  位 序 从 1 开始     p = L;       // p 指向 第一个 结点     while(p && cnt Next;        cnt++;    }    if((cnt == k) && p){    // cnt 等于 k 且 p 指针 存在         return p->Data;    }else{        return ERROR1;    }}` 按 值 查找 从头到尾 遍历 , 直到 找到 为止 . 从 第一个 元素 开始 , 判断  Data[i]  是否 等于 X, 若 是 , 返回 下标 i, 否则 继续 下 一个 . 找 不到 , 返回 ERROR NULL .`c++// 1.2  按 值 查找 #define ERROR2 NULL; //  用 空 地址 表示 错误 Position Find(List L, ElementType X){    Position p = L; // p 指向 第一个 结点     while( p && p->Data != X){        p = p->Next;    }    //  直接 return p  也 可以     if(p){        return p;    }else{        return ERROR2;    }}` 插入 普通 插入 在 指定 位 序  i  前 插入 一个 新元素  X . 当 位 序 为  1  时 , 插入 链表 的 头 ,i 为  n+1  时 , 插入 链表 尾 . 基本思路 :   如果 i 不 为 1, 则 找到 位 序 为  i-1  的 结点 ;  若 存在 , 则 申请 一个 新 结点 并 在 数据 域 天上 相应 值 X, 然后 将 新 结点 插入 到 结点  pre  之后 , 返回 结果 链表 ; 如果 不 存在 则 范 湖 错误信息 .`c++//  插入 #define ERROR3 NULL  //  用 空 地址 表示 错误 List Insert(List L, ElementType X, int i){    Position tmp, pre;    tmp = (Position)malloc(sizeof(struct LNode));   //  申请 , 填装 结点     tmp->Data = X;    if(i == 1){ //  新 结点 在 表头 指针         tmp->Next = L;        return tmp; //   返回 新 表头 指针     }else{        //  查找 位 序 为 i-1 的 节点         int cnt = 1;    //  位 序 从 1 开始         pre = L;    // pre 指向 L 的 第一个 结点         while(pre && cnt Next;            cnt++;        }        if(pre == NULL || cnt != i-1){            printf(\" 插入 位置 参数 错误 \\n\");            free(tmp);            return ERROR3;        }else{  //  找到 待 插 结点 的 前 一个 结点 pre            // 插入 新 结点 并 返回 表头 L            tmp->Next = pre->Next;            pre->Next = tmp;            return L;        }    }}` 带头 结点 的 链式 表 的 插入 上述 函数 表头 指针 L 的 值 可能 会 发生变化 --- 当 插入 发生 在 表头 时 ,L 需要 将 指向 新 的 表头 结点 ; 其他 情况  L  值 不变 所以 我们 可以 为 链表 增加 一个 空 的  ' 头 结点 ' , 真正 的 元素 连接 在 这个 空 结点 之后 .  这样 做 的 好处 是 , 无论 在 哪里 插入 或 删除 ,L 的 值 一直 指向 固定 的 空 结点 , 不会 改变 . 算法 的 时间 复杂度 是  O(n).`c++//  带头 结点 的 链式 表 的 插入 bool Insert(List L, ElementType X, int i){   //  这里 默认 L 有 头 结点     Position tmp, pre;    int cnt = 0;    //  查找 位 序 为 i-1 的 结点     pre = L;    // pre 指向 表头     while(pre && cnt Next;        cnt++;    }    if(pre == NULL || cnt != i-1){  //  所 找 结点 不 在 L 中         printf(\" 插入 位置 参数 错误 !\");        return false;    }else{  //  找到 了 待 插 结点 的 前 一个 结点 pre, 若 i 为 1,pre 就 指向 表头         //  插入 新 结点         tmp = (Position)malloc(sizeof(struct LNOde));   //  申请 , 填装 结点         tmp->Data = X;        tmp->Next = pre->Next;        pre->Next = tmp;        return true;    }}` 带头 结点 的 链式 表 的 删除 在 单向 链表 中 删除 指定 位 序 i 的 元素 , 首先 需要 找到 被 删除 结点 的 前 一个 元素 , 然后 删除 结点 并 释放 空间 . 时间 复 制度  O(n).`c++//  带头 结点 的 链式 表 的 删除 bool Delete(List L, int i){   //  这里 默认 L 有 头 结点     Position tmp, pre;    int cnt = 0;    //  查找 位 序 为 i-1 的 结点     pre = L;    // pre  指向 表头     while(pre && cnt Next;        cnt++;    }    if(pre == NULL || cnt != i-1 || pre->Next == NULL){        //  所 找 结点 或 位 序 为 i 的 结点 不 在 L 中         printf(\" 插入 位置 参数 错误 !\");        return false;    }else{  //  找到 待 删 结点 的 前 一个 结点 pre        //  将 结点 删除         tmp = pre->Next;        pre->Next = tmp->Next;        free(tmp);        return true;    }}` 线性表 注意 在 单链 表 上 插入 , 删除 一个 结点 , 必须 知道 其 前驱 结点 单链 表 不 就 有 按 序号 随机 访问 的 特点 , 只能 从头 指针 开始 一个个 顺序 执行 TODO:  广义 表 和 多重 链表 链式 存储 的 图表 演示 :","title":" 线性表 (List)","oriTitle":"线性表(List)"},{"uri":"\\posts\\3.3datasturcturestack","tags":["Data Sturcture","Stack"],"content":" 堆栈 (Stack)>  堆栈 是 先进后出 (FILO) 堆栈 的 定义 类型 名称 :  堆栈 (Stack) 数据 对象 集 :  一个 有 0 个 或 多个 元素 的 有 穷 线性表 操作 集 :  对于 一个 具体 的 长度 为 正整数 的 MaxSize 的 堆栈 S ∈ Stack ,  记 堆栈 中 的 任一 元素  X ∈ ElementType 堆栈 的 基本操作 :    Stack CreateStack(int MaxSize);  //  生成 空 堆栈 , 其 最大 长度 为 MaxSize    bool IsFull(Stack S);    //  判断 堆栈 S 是否 已 满 . 若 S 中 元素 个数 等于 MaxSize 时 返回 true, 否则 返回 false;    bool Push(Stack short, ElementType X);   //  将 元素  X  压 入 堆栈 . 若 堆栈 已 满 , 返回 false. 否则 将 元素  X  插入 到 堆栈  S  栈 顶 处 并 返回 true    ElementType Pop(Stack S);    //  删除 并 返回 栈 顶 元素 . 若 堆栈 为 空 , 返回 错误信息 , 否则 将 栈 顶 数据 元素 从 堆栈 删除 并 返回 堆栈 的 顺序存储 实现 顺序   类型定义 栈 的 顺序存储 结构 通常 由 一个 一维 数组 和 一个 记录 栈 顶 元素 位置 的 变量 组成 , 另外 我们 还有 一个 变量 MaxSize 用来 存储 堆栈 的 最大 容量 , 方便 判断 堆栈 是否 已 满 用 Data[MaxSize]( 下标 0~MaxSize-1) 来 存储 一个 栈 的 元素 . 栈 底 是 下标 小 的 那 端 ,Top 记录 栈 顶 的 下 标值 . 当 Top 指向 -1 时 , 表示 空 栈 , 指向 MaxSize-1  表示 栈 满 .`c++typedef int Position;typedef struct SNode * PtrToSNode;struct SNode{    ElementType *Data;  //  存储 元素 的 数组     Position Top;   //  栈 顶 指针     int MaxSize;    //  堆栈 最大 容量 };typedef PtrToSNode Stack; 创建 空 堆栈 创建 一个 给定 容量 的 空 堆栈      申请 堆栈 的 空间      申请 数组 的 空间     Top 栈 顶 指针 指向 -1  表示   空 栈      最大 容量 为 MaxSize`c++//  创建 一个 给定 容量 的 空 堆栈 的 函数 Stack CreateStack(int MaxSize){    Stack S = (Stack)malloc(sizeof(struct SNode));    S->Data = (ElementType )malloc(MaxSize  sizeof(ElementType));    S->Top = -1;    S->MaxSize = MaxSize;    return S;}` 顺序   判断 堆栈 是否 已 满 判断 Top 指针 是否 等于 MaxSize-1`c++//  判断 堆栈 S 是否 已 满 bool IsFull(Stack S){    return(S->Top == S->MaxSize-1);}` 顺序   入 栈 操作  Push 先 判断 堆栈 是否 已 满 , 若 不满 Top+1 ,  并 将 元素 放入 Data 数组 的 Top 位置 中 `c++//  入 栈 操作  Pushbool Push(Stack S, ElementType X){    if(IsFull(S)){        printf(\" 堆栈 已 满 \");        return false;    }else{        S->Data[++(S->Top)] = X;        return true;    }}` 顺序   判断 栈 空 判断 Top  指针 是否 指向  -1`c++//  判断 栈 空 bool IsEmpty(Stack S){    return(S->Top == -1);}` 顺序   出 栈 操作  Pop 先 判断 是否 栈 空 , 若 不 空 , 返回 Data[Top], 同时 将 Top-1 否则 返回 一个 ElementType 类型 的 ERROR > ERROR  错误信息 一般 是 根据 具体 问题 做 定义 , 必须 是 正常 的 栈 元素 数据 不 可能 取 到 的 值 `c++//  出 栈 操作  Pop, 删除 并 返回 栈 顶 元素 ElementType Pop(Stack){    if(IsEmpty(S)){        printf(\" 堆栈 空 !\")        return ERROR;   // ERROR  是 ElementType  的 特殊 值 , 标志 错误     }else{        return(S->Data[(S->Top)--]);    }}`TODO:  一个 数组 实现 两个 堆栈 堆栈 的 链式 存储 实现 链式   类型定义 栈 的 链式 存储 结构 ( 链 栈 ) 与 单链 表 类似 , 但 其 操作 受限 , 插入 和 删除 只能 在 链 栈 的 栈 顶 进行 . 栈 顶 指针 Top 就是 链表 的 头 指针 . 为了 简便 算法 , 可以 带 一 空 的 表头 结点 , 表头 结点 后面 第一个 结点 就是 恋战 的 栈 顶 结点 . 栈 中 的 额 其他 结点 通过 他们 的 指针 Next 链接 起来 , 栈 底 节点 的 Next 为 NULL.`c++typedef struct SNode * PtrToSNode;struct SNode{    ElementType Data;    PtrToSNode Next;};typedef PtrToSNode Stack;` 链式   创建 空 栈 申请 栈 空间 设置 栈 底 结点 的 Next 为 NULL`c++//  构建 一个 堆栈 的 头 结点  , 返回 该 节点 指针 , 栈 底 结点 的 Next 为 NULLStack CreateStack(){    Stack S;    S = malloc(sizeof(struct SNode));    S->Next = NULL;    return S;}` 链式   判断 栈 空 判断 栈 底 结点 的 Next  是否 为 NULL`c++//  判断 堆栈 S 是否 为 空 ,  若 是 返回 true , 否则 返回 falsebool IsEmpty(Stack S){    return(S->Next == NULL);}` 链式   入 栈  Push 申请 一个 临时 结点 看 单链 表 图 理解 注意 只能 栈 顶 操作 S->Next = NULL`c++// Push  将 元素 X 压 入 堆栈 Sbool Push(Stack S, ElementType X){    PtrToSNode TmpCell; //  临时 指针     TmpCell = (PtrToSNode)malloc(sizeof(struct SNode));    TmpCell->Next = S->Next;    S->Next = TmpCell;    return true;}` 链式   出 栈  Pop 判断 是否 为 空 看 单链 表 图 理解 注意 只能 栈 顶 操作 S->Next = NULL 释放 空间  free()`c++//  删除 并 返回 堆栈 S 的 栈 顶 元素 ElementType Pop(Stack S){    PtrToSNode FirstCell;    ElementType TopElem;    if(IsEmpty(S)){        printf(\" 堆栈 空 !\");        return ERROR;    }else{        FirstCell = S->Next;        TopElem = FirstCell->Data;        S->Next = FirstCell->Next;        free(FirstCell);        return TopElem; //  返回 栈 顶 元素     }}`TODO:  堆栈 应用 :  表达式 求值 TODO:  使用 堆栈 求 后缀 表达式 堆栈 的 图表 ","title":" 堆栈 (Stack)","oriTitle":"堆栈(Stack)"},{"uri":"\\posts\\3.4datasturcturequeue","tags":["Data Sturcture","Queue"],"content":" 队列 队列 的 定义 类型 名称 :  队列 (Queue) 数据 对象 集 :  一个 有 0 个 或 多个 元素 的 有 穷 线性表 操作 集 :  对于 一个 长度 为 正整数 MaxSize 的 队列  Q ∈ Queue, 记 队列 中 任一 元素  X ∈ ElementType 基本操作 :    Queue CreateQueue(int MaxSize);  //  生成 空 队列 , 其 最大 长度 为 MaxSize    bool IsFull(Queue Q);    //  判断 队列 Q 是否 已 满     bool AddQ(Queue Q, ElementType X);   //  将 元素 X 压 入 队列 Q. 队列 已 满 , 返回 false, 否则 将 数据 元素 X 插入 队列 Q 并 返回 true    bool IsEmpty(Queue Q);   //  判断 队列 Q 是否 为 空 , 若 是 , 返回 true, 否则 false    ElementType DeleteQ(Queue Q);     //  删除 并 返回 队列 头 元素 . 若 队 列为 空 , 返回 错误信息 , 否则 将 队列 头 数据 元素 从 队列 删除 并 返回 队列 的 顺序存储 实现 >  队列 是 先进先出 (FIFO) 溢出 的 两种 解决 方法 .     记录 元素 个数 Size, 每次 Push 和 Pop 都 记录 变量 size. 根据 Size 的 变化 可以 判断 队列 的 是 空 是 满 .     循环 队列  (Rear + 1) % MaxSize = Front    队列 满  Rear = Front  队列 空 类型定义 使用 循环 队列 的 方法 , 防止 队列 溢出 定义 Data 数组 定义 指针 头尾 指针 定义 最大 容量 MaxSize`c++typedef int Position;typedef struct QNode * PtrToQNode;struct QNode{    ElementType * Data; //  存储 元素 的 数组     Position Front, Rear;   //  队列 的 头 , 尾 指针     int MaxSize;    //  队列 最大 容量 };typedef PtrToQNode Queue;` 创建 空 队列 申请 队列 空间 申请 数组 空间 定义 Rear = Front 设置 数组 最大 容量 `c++//  生成 空 队列 , 最大 长度 为 MaxSizeQueue CreateQueue(int MaxSize){    Queue Q = (Queue)malloc(sizeof(struct QNode));    Q->Data = (ElementType )malloc(MaxSize  sizeof(ElementType));    Q->Front = Q->Rear = 0;    Q->MaxSize = MaxSize;    return Q;}` 判断 队列 是否 已 满 判断 (Rear + 1) % MaxSize = Front`c++//  判断 队列 是否 已 满 bool IsFull(Queue Q){    return((Q->Rear+1) % Q->MaxSize == Q->Front);}` 判断 队列 是否 为 空 判断 Rear = Front`c++//  判断 队列 是否 为 空 bool IsEmpty(Queue Q){    return(Q->Front == Q->Rear);}` 压 入 队列 判断 是否 队列 已 满 对 队列 的 尾 指针 操作 `c++//  将 元素 X 压 入 队列 bool AddQ(Queue Q, ElementType X){    if(IsFull(Q)){        printf(\" 队列 已 满 \");        return false;    }else{        Q->Rear = (Q->Rear + 1) % Q->MaxSize;        Q->Data[Q->Rear] = X;        return true;    }}` 队列 的 删除 操作 判断 为 空 对 队列 的 头 指针 操作 `c++//  删除 并 返回 队列 的 头 元素 ElementType DeleteQ(Queue Q){    if(IsEmpty(Q)){        printf(\" 队列 空 \");        return ERROR;    }else{        Q->Front = (Q->Front + 1) % MaxSize;        return Q->Data[Q->Front];    }}` 队列 的 链式 存储 实现 队列 的 头 指针 (Front) 必须 指向 链表 的 头 结点 队列 的 尾 (Rear) 指向 链表 的 尾 结点 `c++typedef struct Node * PtrToNode;struct Node{    //  队列 中 的 结点     ElementType Data;    PtrToQNode Next;};typedef PtrToQNode Position;typedef struct QNode * PtrToQNode;struct QNode{    Position Front, Rear;   //  队列 的 头尾 指针     int MaxSize;            //  队列 的 最大 容量 };typedef PtrToQNode Queue;` 链表   判断 队列 是否 为 空 `c++//  判断 队列 是否 为 空 bool IsEmpty(Queue Q){    return(Q->Front == NULL);}` 链表   删除 操作 判断 是否 为 空 删除 头 结点 ( 判断 是否 只有 一个 元素 或 多个 元素 ) 释放 空间 `c++//  删除 队列 头 结点 ElementType DeleteQ(Queue Q){    Position FrontCell;    ElementType FrontElem;    if(IsEmpty(Q)){        printf(\" 队列 空 !\");        return ERROR;    }else{        FrontCell = Q->Front;        if(Q->Front == Q->Rear){    //  若 队列 只有 一个 元素             Q->Front = Q->Rear = NULL;  //  删除 后 队列 置 为 空         }else{            Q->Front = Q->Front->Next;        }        FrontElem = FrontCell->Data;        free(FrontCell);    //  释放 被 删除 结点 空间         return FrontElem;    }}`TODO:  应用 实例 : 多项式 加法 运算 TODO:  迷宫 问题 队列 的 图 ","title":" 队列 (Queue)","oriTitle":"队列(Queue)"},{"uri":"\\posts\\android-change-underline-color","tags":["EditText","Android"],"content":"Android EditText 下划线 颜色 变换 首先 要 用到 style.xml 文件 , 新建 自定义 EditText 控件 style  res->values->style.xml  添加     `xml        @android:color/white        @android:color/holobluedark    `     不 点击 时 设置 white, 点击 时 设置 blue 然后 在 布局 中 的 EditText 控件 中 添加 theme 属性     android:theme=\"@style/MyEditText\"    `xml    ` 效果  :","title":"Android EditText 下划线 颜色 变换 ","oriTitle":"Android EditText下划线颜色变换"},{"uri":"\\posts\\android-custom-dialog-to-achieve-sex%2Cdate%2Cand-listen-edittext-","tags":["Dialog"],"content":"Android  自定义  Dialog , 实现   性别 选择 , 日期 选择 和   自定义 布局 获取 EditText 内容 > Dialog 类 是 对话框 的 基类 , 但是 应该 避免 直接 实例 化 Dialog, 而是 应该 尽量 使用 下列 子 列 之一  :> AlertDialog 此 对话框 可 显示 标题 、 最 多 三个 按钮 、 可 选择项 列表 或 自定义 布局 。DatePickerDialog  或  TimePickerDialog 此 对话框 带有 允许 用户 选择 日期 或 时间 的 预定 义  UI。------------------------------------------------ 来自 于 Google Android Develop  开发 手册 日期 选择器 这里 我们 用到 了 Android 原生 提供 的 日期 选择器 对话框  DatePickerDialog 首先 你 可以 先 设定 一个 date, 让 DatePickerDialog  点击 时 显示 你 设定 的 时间 . 通常 我们 都 是 获取 当前 date 来 显示 . 所以 我们 要 用到 calender 来 获取 当前 date`javaCalendar nowdate = Calendar.getInstance();int mYear = nowdate.get(Calendar.YEAR);int mMonth = nowdate.get(Calendar.MONTH);int mDay = nowdate.get(Calendar.DAYOFMONTH);` 然后 你 可以 在 按钮  onClick()  点击 事件 中 设置 触发  DatePickerDialog     传入 五个 参数  parent context , 监听器 , 年 , 月 , 日 `javanew DatePickerDialog(MainActivity.this, onDateSetListener, mYear, mMonth, mDay).show();` 设置 日期 选择器 对话框 的 监听器  , DatePickerDialog.OnDateSetListener  void onDateSet (DatePicker view,                int year,                int month,                int dayOfMonth)   将 获取 到 的 date 转换成 字符串 显示 到 textview`javaprivate DatePickerDialog.OnDateSetListener onDateSetListener = new DatePickerDialog.OnDateSetListener() {        @Override        public void onDateSet(DatePicker view, int year, int monthOfYear, int dayOfMonth) {            int mYear = year;            int mMonth = monthOfYear;            int mDay = dayOfMonth;            TextView datetextview = (TextView) findViewById(R.id.changebirthtextview);            String days;            days = new StringBuffer().append(mYear).append(\" 年 \").append(mMonth).append(\" 月 \").append(mDay).append(\" 日 \").toString();            date_textview.setText(days);        }    };`>  参考 自 Google Android Develop DatePickerDialog 性别 选择器 首先 我们 要 创建 一个 数组 , 来 提供 选择 的 选项   `java  private String[] sexArry = new String[]{\" 不 告诉 你 \", \" 女 \", \" 男 \"};//  性别 选择   ` 设置 点击 事件 后 , 实现 性别 选择器 的 方法  , 这里 我们 使用 了 AlertDialog`javaprivate void showSexChooseDialog() {        AlertDialog.Builder builder3 = new AlertDialog.Builder(this);//  自定义 对话框         builder3.setSingleChoiceItems(sexArry, 0, new DialogInterface.OnClickListener() {// 2 默认 的 选中             @Override            public void onClick(DialogInterface dialog, int which) {// which 是 被 选中 的 位置                 // showToast(which+\"\");                changesex_textview.setText(sexArry[which]);                dialog.dismiss();//  随便 点击 一个 item 消失 对话框 ， 不用 点击 确认 取消             }        });        builder3.show();//  让 弹 出 框 显示     }` 自定义 Dialog  布局 , 获取 EditText 输入框 的 数据 使用 使用 LayoutInflater 来 加载 dialog_setname.xml 布局 初始化 AlertDialog, 使用 setView() 方法 将 自定义 View 显示 到 dialog 设置 AlertDialog 的 按钮 , 设置 点击 事件 来   获取 EditText 输入框 的 内容 , 然后 设置 TextView 的 内容 . 布局 文件 `xml` 自定义 Dialog 获取 输入框 内容 方法 `javaprivate void onCreateNameDialog() {        //  使用 LayoutInflater 来 加载 dialog_setname.xml 布局         LayoutInflater layoutInflater = LayoutInflater.from(this);        View nameView = layoutInflater.inflate(R.layout.dialog_setname, null);        AlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(                this);        //  使用 setView() 方法 将 布局 显示 到 dialog        alertDialogBuilder.setView(nameView);        final EditText userInput = (EditText) nameView.findViewById(R.id.changename_edit);        final TextView name = (TextView) findViewById(R.id.changename_textview);        //  设置 Dialog 按钮         alertDialogBuilder                .setCancelable(false)                .setPositiveButton(\"OK\",                        new DialogInterface.OnClickListener() {                            public void onClick(DialogInterface dialog, int id) {                                //  获取 edittext 的 内容 , 显示 到 textview                                name.setText(userInput.getText());                            }                        })                .setNegativeButton(\"Cancel\",                        new DialogInterface.OnClickListener() {                            public void onClick(DialogInterface dialog, int id) {                                dialog.cancel();                            }                        });        // create alert dialog        AlertDialog alertDialog = alertDialogBuilder.create();        // show it        alertDialog.show();    }` 通常 的 AlertDialog   实现 退出 账号 效果 设置 Yes 和 Cancel 按钮 和 点击 事件 `javaAlertDialog.Builder builder1 = new AlertDialog.Builder(MainActivity.this);builder1.setMessage(\" 确定 退出 账号 ?\")        .setPositiveButton(\"Yes\", new DialogInterface.OnClickListener() {              public void onClick(DialogInterface dialog, int id) {                  finish();  //  这里 使用 finish()  模拟 下 退出 账号 ~              }        })        .setNegativeButton(\"No\", new DialogInterface.OnClickListener() {              public void onClick(DialogInterface dialog, int id) {                  // User cancelled the dialog              }        });// Create the AlertDialog object and return itbuilder1.show();` 城市 选择器 目前 还 没有 实现 ...  但是 我 在 看 Github 上 的 citypicker   目前 还 在 学习 中 , 如果 有 实现 的 可以 讨论一下 .> Google Android Develop Dialog","title":"Android  自定义  Dialog","oriTitle":"Android 自定义 Dialog"},{"uri":"\\posts\\android-studio-gradle-the-program-of-download","tags":["Gradle","Android"],"content":" 安装 Android Studio  时 遇到   Buileing \"xxx\" Gradle project info  的 解决 方法 我 第一次 启动 Android Studio 的 时候 , 遇到  Grale  一直 下载 不 下来 , 后来 找到 解决 方法  1. 首先 在  C:\\Users\\ 用户名 \\.gradle\\wrapper\\dists  文件夹 中 查看 需要 下载 那个 版本 的 Gradle 2. 之后 去 http://services.gradle.org/distributions/   下载 你 需要 的 版本  3. 下载 后 ， 将 压缩包 放到   C:\\Users\\ 用户名 \\.gradle\\wrapper\\dists\\gradle-x.x-all\\xxxxxxxxxxxxxxx 4. 重写 启动 Studio 即可 ","title":" 解决 Android Studio Gradle  下载 问题 ","oriTitle":"解决Android Studio Gradle 下载问题"},{"uri":"\\posts\\android-studio-thewaytosolveslow","tags":["Studio","Android"],"content":" 解决 Android Studio 太卡 的 方法 修改 Java  虚拟机 启动 时 的 参数 ， 用于 限制 最大 堆 内 存在 Android Studio Help->Edit Custom VM Option    打开 在 这里 加上   -Xmx2g  或者  -Xmx4g 如何 查看 生效 呢 ？Settings 设置 重新启动 Android Studio  在 右下角 看 是否 显示 内存 使用 情况 还有 不 懂得 可以 查看 官方 文档 ：🔎developer.android","title":" 解决 Android Studio 太卡 的 方法 ","oriTitle":"解决Android Studio太卡的方法"},{"uri":"\\posts\\color.xml-resource-file","tags":["Android Values","Android"],"content":"colors.xml 资源 文件 在 开发者 进行 android 开发 的 时候 , 往往 要 设置 很多 颜色 , 通常 使用 RGB 颜色 比如    代表 绿色 但是 一个 项目 有 很多 地方 要 使用 的 不同 颜色 , 这么 多 RGB 值 会 搞 混淆 , 所以 可以 使用 color.xml 文件 给 指定 颜色 命名 打开 res->values->colors.xml 添加  : 然后 在 控件 属性 可以 添加 color","title":"Android colors.xml 资源 文件 ","oriTitle":"Android colors.xml资源文件"},{"uri":"\\posts\\datasturcturebase","tags":["Data Sturcture"],"content":" 数据结构 实现 基础 数据 存储 基础 数组 `c++int a[];a[i];int a[5] = {1,2,3,4,5};int a3;a1;` 类型定义 `typedef  原有 类型 名   新 类型 名 ;typedef int ElementType;` 指针 指针 变量 是 用 啦 存放 变量 的 地址 。 指针 变量 要 先 赋值 才能 使用 。 指针 可以 基本 运算 。`c++ 类型 名  * 指针 变量名 ；float *p;` 指针 与 数组 动态存储分配 函数     void m*malloc(unsigned size) 动态 存储 释放 函数  void free(void *ptr) 结构 结构 类型定义 `c++struct  结构 名 {     类型 名   结构 成员 名 1;     类型 名   结构 成员 名 2;    ...     类型 名   结构 成员 名 n;};` 结构 变量 的 使用 结构 变量名 . 结构 成员 名 结构 数组 结构 数组名 [ 下标 ]. 结构 成员 名 结构 指针 通过 指针 访问 结构 , 也 可以 通过 指针 直接 访问 结构 成员 用 方式 访问  : ( 结构 指针 变量名 ). 结构 成员 名 用 指向 运算符  \" -> \"  访问 指针 指向 的 结构 成员 :  结构 指针 变量名 -> 结构 成员 名 结构 指针 当做 函数 参数传递 , 传递 效率高 . 共用 体 不同 的 数据项 组织 成 一个 整体 , 他们 在 内存 中 占有 同 一段 存储单元 `c++union  共用 体 名 {     类型 名   成员 名 1;     类型 名   成员 名 2;    ...     类型 名   成员 名 n;};` 链表 单向 链表 通常 使用 结构 的 嵌套 来 定义 单向 链表 结点 的 数据类型      结构 类型 Node 中 的 Next 分量 又 是 该 结构 类型 的 指针 , 称之为 结构 的 递归 定义 .     方便 阅读 , 讲 指针 重命名 为 PtrToNode, 即 指向 Node 的 指针      除了 Next 分量 , 还有 Data 表示 结点 信息 `c++typedef struct Node *PtrToNode;struct Node{    ElementType Data;   /*  存储 结点 数据  */    PtrToNode Next;     /*  指向 下 一个 结点 的 指针  */};` 通常 我们 给定 一个 单链 表 , 就是 给定 一个 指向 该 链表 头 结点 的 指针 , 所以 单链 表 类型 List 可以 定义 为 链表 结点 结构 的 指针  typedef PtrToNode List 动态 数据结构      进行 动态分配 的 操作 ,malloc() 和 free()    PtrToNode p = (PtrToNode)malloc(sizeof(struct Node)); 流程 控制 基础 if{}else{}while,for,do...while 函数 与 递归 `c++ 函数 类型   函数 名 ( 形 参 表 )   /*  函数 首部  */{     函数 实现 过程 ;         /*  函数 体  */}`","title":" 数据结构 实现 基础 ","oriTitle":"数据结构实现基础"},{"uri":"\\posts\\data_structure_mindmap","tags":[],"content":"Data Structure  数据结构 思维 导 图 整理 >  这个 思维 导 图 根据 自 中国大学 MOOC 的 浙大 数据结构 课 的 目录 . 目前 我 还是 好多 没有 掌握 树 的 那 一块 , 递归函数 要 多 理解 . 指针 和 类型定义 图 散 列 > 已经 报名 了 2018 年 3 月 的 春季 PAT 考试 , 希望 在 寒假 的 时候 啃 完 晴 神 宝典 , 在 考试 考 到 50 分 .😝","title":"Data Structure  思维 导 图 ","oriTitle":"Data Structure 思维导图"},{"uri":"\\posts\\git-and-github","tags":["git","github"],"content":"Git  和  Github 的 使用 札记 git    git init   //  创建 本地 仓库     git status //  掌握 仓库 当前 的 状态     git add    //  添加 修改 文件 到 stage    git commit -m\"text\"//  提交 文件 到 Git 仓库 github    git remote add origin git@github.com:username/repository.git  //  让 本地 仓库 与 远程 仓库 连接     git clone  git@github.com:username/repository.git  //  从 远程 仓库 clone    git push -u origin master //  推送 本地 仓库 文件 到 远程 仓库     git push -f origin master //  强制 推送 创建 SSH KEY    ssh-keygen -t rsa -C \"youremail@example.com\" 在 系统 用户 主目录 找到 .ssh 文件夹 , 复制 id_rsb.pub 内容 , 添加 到  https://github.com/settings/keys 连接 多个 远程 仓库     git remote -v  //  查看 目前 远程 库 信息     git remote rm origin //  删除 远程 库     git remote add github git@github.com:username/repository.git  //  关联 github    git remote add gitee git@github.com:username/repository.git  //  关联 gitee    // 推送     git push github master    git push gitee master 自定义  git    .gitignore  //  配置 .gitignore  忽略 特殊 文件     // 设置 别名     $ git config --global alias.st status    $ git config --global alias.co checkout    $ git config --global alias.ci commit    $ git config --global alias.br branch","title":"Git 和 Github 使用 札记 ","oriTitle":"Git和Github使用札记"},{"uri":"\\posts\\translucent-bar-immersive-bar","tags":["Android"],"content":" 如何 做到 沉浸 式 状态栏 --- 更加 准确 的 说 是 透明 状态栏  Translucent Bar 设置 imageView 图片   高 宽  match_parent   但是 没有 隐藏 ActionBar 效果 : 透明 状态栏 和 隐藏 ActionBar 在 activity 文件 中 添加 `java//  显示 activity_main 布局 super.onCreate(savedInstanceState);setContentView(R.layout.activity_main);// 透明 状态栏 if (Build.VERSION.SDK_INT >= 21) {    View decorView = getWindow().getDecorView();    int option = View.SYSTEMUIFLAGLAYOUTFULLSCREEN            | View.SYSTEMUIFLAGLAYOUTSTABLE;    decorView.setSystemUiVisibility(option);    getWindow().setStatusBarColor(Color.TRANSPARENT);}//  隐藏 系统 自带 应用 栏 ActionBar actionBar = getSupportActionBar();actionBar.hide();` 这种 效果 只有 5.0 及 以上 系统 支持 使用 了 SYSTEMUIFLAGLAYOUTFULLSCREEN 和 SYSTEMUIFLAGLAYOUTSTABLE， 注意 两个 Flag 必须 要 结合 在 一起 使用 ， 表示 会 让 应用 的 主体 内容 占用 系统 状态栏 的 空间 最后 再 调用 Window 的 setStatusBarColor() 方法 将 状态栏 设置 成 透明 色 就 可以 了 。>  需要 注意 的 是 ， 这 一种 变成 透明 状态栏 的 方法 要 注意 你 设置 的 自定义 的 ActionBar( 一般 为 56dp) 的 高度 要 加上 状态栏 的 高度 （ 一般 为 20dp) 效果 ：","title":"Android  沉浸 式 状态栏 ","oriTitle":"Android 沉浸式状态栏"}]